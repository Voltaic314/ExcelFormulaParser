import pytest
import pandas as pd
from Models.range import Range

class TestCellRange:

    def test_valid_range_initialization(self):
        """ Test initialization with valid range strings. """
        # Initialization using a single range string
        range = Range('A1:C3')
        assert str(range.start_cell) == 'A1'
        assert str(range.end_cell) == 'C3'
        
        # Testing with separate start and end references
        range = Range('A1', 'C3')
        assert str(range.start_cell) == 'A1'
        assert str(range.end_cell) == 'C3'

    def test_invalid_range_format(self):
        """ Test initialization with invalid range formats should raise ValueError. """
        with pytest.raises(ValueError):
            Range('A1C3')  # No colon separator
        with pytest.raises(ValueError):
            Range('A1:')  # Missing end reference
        with pytest.raises(ValueError):
            Range(':A1')  # Missing start reference
        with pytest.raises(ValueError):
            Range('1A:C3')  # Invalid start reference
        with pytest.raises(ValueError):
            Range('A1:3C')  # Invalid end reference

    def test_range_string_representation(self):
        """ Test the string representation of a cell range. """
        range = Range('A1', 'B2')
        assert str(range) == 'A1:B2'

    def test_iterable_functionality(self):
        """ Test that the Range object can be iterated over and contains specific cells. """
        range_inst = Range('A1:C3')
        expected_cells = ['A1', 'B1', 'C1', 'A2', 'B2', 'C2', 'A3', 'B3', 'C3']
        cells = [cell for cell in range_inst]  # This uses the Range's __iter__ method
        assert cells == expected_cells, f"Expected {expected_cells}, but got {cells}"

    def test_membership(self):
        """ Test membership of cells in a range. """
        range = Range('A1:B2')
        assert 'A1' in range, "'A1' should be in range A1:B2"
        assert 'A3' not in range, "'A3' should not be in range A1:B2"
        assert 'B2' in range, "'B2' should be in range A1:B2"
        assert 'C1' not in range, "'C1' should not be in range A1:B2"

    def test_cells_generated_by_iteration(self):
        """ Test cells generated by the iterator directly match expected 2D list pattern. """
        range_inst = Range('A1:B2')
        expected_cells = [['A1', 'B1'], ['A2', 'B2']]
        cells_list = []
        for row in range_inst.cell_matrix:
            cells_list.append(row)
        assert cells_list == expected_cells

    def test_to_dict(self):
        """ Test the dictionary representation of a cell range. """
        range = Range('A1', 'C3')
        expected_dict = {
            "range": "A1:C3",
            "components": {
                "start": "A1",
                "end": "C3"
            }
        }
        assert range.to_dict() == expected_dict

    def test_rows_and_columns_in_range(self):
        """ Test getting rows and columns from the range. """
        range = Range('A1', 'C3')
        assert range.get_rows_in_range() == [1, 2, 3]
        assert range.get_columns_in_range(as_numbers=True) == [1, 2, 3]
        assert range.get_columns_in_range() == ['A', 'B', 'C']

    def test_cells_in_range(self):
        """ Test getting all cells in the range. """
        range = Range('A1', 'B2')
        expected_cells = [['A1', 'B1'], ['A2', 'B2']]
        assert range.get_cells_in_range() == expected_cells

        df = range.get_cells_in_range(as_dataframe=True)
        assert df.equals(pd.DataFrame(expected_cells, index=['Row 1', 'Row 2'], columns=['A', 'B']))

    def test_from_dict(self):
        """ Test creating a cell range from a dictionary. """
        range_dict = {
            "range": "A1:C3",
            "components": {
                "start": "A1",
                "end": "C3"
            }
        }
        range = Range.from_dict(range_dict)
        assert str(range) == range_dict["range"] # should both be "A1:C3"
        assert str(range.start_cell) == range_dict["components"]["start"]
        assert str(range.end_cell) == range_dict["components"]["end"]
        # end cell, not to be confused with incel ecks dee 
